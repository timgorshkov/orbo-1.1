-- Migration 212: QR Check-in System
-- Date: Feb 7, 2026
-- Purpose: Add qr_token, checked_in_at columns, expand status constraint for event check-in

-- ============================================
-- STEP 1: Add qr_token and checked_in_at columns
-- ============================================

ALTER TABLE event_registrations
ADD COLUMN IF NOT EXISTS qr_token TEXT UNIQUE,
ADD COLUMN IF NOT EXISTS checked_in_at TIMESTAMPTZ;

COMMENT ON COLUMN event_registrations.qr_token IS 'Unique token for QR code check-in (UUID format)';
COMMENT ON COLUMN event_registrations.checked_in_at IS 'Timestamp when participant checked in at the event';

-- ============================================
-- STEP 2: Expand status constraint to include attended/no_show
-- ============================================

-- Drop old constraint (it was ('registered', 'cancelled') from migration 19)
ALTER TABLE event_registrations DROP CONSTRAINT IF EXISTS event_registrations_status_check;

-- Add new constraint with check-in statuses
ALTER TABLE event_registrations ADD CONSTRAINT event_registrations_status_check
  CHECK (status IN ('registered', 'cancelled', 'attended', 'no_show'));

-- ============================================
-- STEP 3: Backfill qr_token for existing registrations
-- ============================================

UPDATE event_registrations
SET qr_token = gen_random_uuid()::text
WHERE qr_token IS NULL AND status != 'cancelled';

-- ============================================
-- STEP 4: Create trigger to auto-generate qr_token on insert
-- ============================================

CREATE OR REPLACE FUNCTION set_registration_qr_token()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.qr_token IS NULL THEN
    NEW.qr_token := gen_random_uuid()::text;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trigger_set_registration_qr_token ON event_registrations;
CREATE TRIGGER trigger_set_registration_qr_token
  BEFORE INSERT ON event_registrations
  FOR EACH ROW
  EXECUTE FUNCTION set_registration_qr_token();

-- ============================================
-- STEP 5: Create index for qr_token lookups
-- ============================================

CREATE INDEX IF NOT EXISTS idx_event_registrations_qr_token 
ON event_registrations(qr_token) 
WHERE qr_token IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_event_registrations_checked_in
ON event_registrations(event_id, status)
WHERE status = 'attended';

-- ============================================
-- STEP 6: Update RPC function to return qr_token
-- ============================================

DROP FUNCTION IF EXISTS register_for_event(UUID, UUID, JSONB, INTEGER);

CREATE OR REPLACE FUNCTION register_for_event(
  p_event_id UUID,
  p_participant_id UUID,
  p_registration_data JSONB DEFAULT '{}'::jsonb,
  p_quantity INTEGER DEFAULT 1
)
RETURNS TABLE (
  registration_id UUID,
  registration_event_id UUID,
  registration_participant_id UUID,
  registration_status TEXT,
  registration_source TEXT,
  registration_data JSONB,
  registration_quantity INTEGER,
  registration_registered_at TIMESTAMPTZ,
  registration_qr_token TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_org_id UUID;
  v_event_org_id UUID;
  v_registration RECORD;
BEGIN
  -- Verify participant exists and get org_id
  EXECUTE format('SELECT org_id FROM %I.participants WHERE id = $1', 'public')
    INTO v_org_id
    USING p_participant_id;
  
  IF v_org_id IS NULL THEN
    RAISE EXCEPTION 'Participant not found';
  END IF;
  
  -- Verify event exists and get org_id
  EXECUTE format('SELECT org_id FROM %I.events WHERE id = $1', 'public')
    INTO v_event_org_id
    USING p_event_id;
  
  IF v_event_org_id IS NULL THEN
    RAISE EXCEPTION 'Event not found';
  END IF;
  
  IF v_org_id != v_event_org_id THEN
    RAISE EXCEPTION 'Participant and event must belong to the same organization';
  END IF;
  
  -- Insert registration (qr_token auto-generated by trigger)
  EXECUTE format('
    INSERT INTO %I.event_registrations (
      event_id,
      participant_id,
      registration_source,
      status,
      registration_data,
      quantity
    )
    VALUES ($1, $2, $3, $4, $5, $6)
    RETURNING *',
    'public'
  )
  INTO v_registration
  USING p_event_id, p_participant_id, 'web', 'registered', p_registration_data, p_quantity;
  
  -- Return the created registration
  registration_id := v_registration.id;
  registration_event_id := v_registration.event_id;
  registration_participant_id := v_registration.participant_id;
  registration_status := v_registration.status;
  registration_source := v_registration.registration_source;
  registration_data := v_registration.registration_data;
  registration_quantity := v_registration.quantity;
  registration_registered_at := v_registration.registered_at;
  registration_qr_token := v_registration.qr_token;
  
  RETURN NEXT;
END;
$$;

COMMENT ON FUNCTION register_for_event IS 'Registers a participant for an event with auto-generated QR token, bypassing RLS policies.';

-- Set function owner to postgres (superuser) to ensure RLS is bypassed
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'postgres') THEN
    ALTER FUNCTION register_for_event(UUID, UUID, JSONB, INTEGER) OWNER TO postgres;
  END IF;
EXCEPTION
  WHEN insufficient_privilege THEN
    RAISE NOTICE 'Could not set function owner to postgres';
END $$;

DO $$ BEGIN RAISE NOTICE 'Migration 212 Complete: QR Check-in system â€” qr_token, checked_in_at, expanded statuses, updated RPC.'; END $$;
